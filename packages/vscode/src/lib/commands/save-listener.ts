import * as vscode from 'vscode';
import { CSVWActionsProvider } from '../tree-data-provider.js';
import { updateInputFilesFromDescriptor } from '../command-handlers.js';
import { convertRDF2CSVW, convertCSVW2RDF } from '../conversion-logic.js';
import type { ConversionItem } from '../types.js';

/**
 * Finds the conversion that matches the changed file path.
 * Returns null if the file is an output file (to prevent recursive saves) or if no matching conversion is found.
 * @param filePath - The absolute path of the file that was saved
 * @param conversions - Array of conversion items to search through
 * @returns The matching conversion item or null if no match found or if file is an output file
 */
function findMatchingConversion(
  filePath: string,
  conversions: (ConversionItem | null)[],
): ConversionItem | null {
  for (const conv of conversions) {
    if (!conv) continue;

    if (
      filePath === conv.outputFilePath ||
      (conv.outputFilePaths && conv.outputFilePaths.includes(filePath))
    ) {
      return null;
    }

    if (
      filePath === conv.descriptorFilePath ||
      filePath === conv.inputFilePath ||
      filePath === conv.rdfInputFilePath ||
      (conv.additionalInputFilePaths &&
        conv.additionalInputFilePaths.includes(filePath))
    ) {
      return conv;
    }
  }
  return null;
}

/**
 * Handles descriptor file saves by updating input files based on table URLs in the descriptor.
 * This function extracts table URLs from the descriptor and creates corresponding input files.
 * @param conversion - The conversion item whose descriptor was saved
 * @returns Promise resolving to true when input files have been updated
 */
async function handleDescriptorSave(
  conversion: ConversionItem,
): Promise<boolean> {
  const descriptorEditor = vscode.window.visibleTextEditors.find(
    (editor) => editor.document.uri.fsPath === conversion.descriptorFilePath,
  );

  if (descriptorEditor) {
    const descriptorContent = descriptorEditor.document.getText();
    await updateInputFilesFromDescriptor(conversion, descriptorContent);
  }
  return true;
}

/**
 * Determines if the conversion direction is RDF to CSVW based on the saved file path.
 * @param filePath - The absolute path of the file that was saved
 * @param conversion - The conversion item to check against
 * @returns True if converting from RDF to CSVW, false if converting from CSVW to RDF
 */
function isRdfToCSVWConversion(
  filePath: string,
  conversion: ConversionItem,
): boolean {
  return filePath === conversion.rdfInputFilePath;
}

/**
 * Performs the actual conversion based on the direction determined by the saved file.
 * Handles both CSVW-to-RDF and RDF-to-CSVW conversions with appropriate options.
 * @param conversion - The conversion item containing conversion settings and file paths
 * @param descriptorContent - The CSVW descriptor content as a string
 * @param isRdfToCSVW - True for RDF→CSVW conversion, false for CSVW→RDF conversion
 * @returns Promise resolving to an array of output file paths generated by the conversion
 * @throws Error if the conversion process fails
 */
async function performConversion(
  conversion: ConversionItem,
  descriptorContent: string,
  isRdfToCSVW: boolean,
): Promise<string[]> {
  if (isRdfToCSVW) {
    return await convertRDF2CSVW(
      descriptorContent,
      conversion.rdfInputFilePath,
      conversion,
    );
  } else {
    const templateIRIs = conversion.templateIRIsChecked || false;
    const minimalMode = conversion.minimalModeChecked || false;
    return await convertCSVW2RDF(
      descriptorContent,
      { templateIris: templateIRIs, minimal: minimalMode },
      conversion,
    );
  }
}

/**
 * Updates the conversion structure with output file paths and filters out error files.
 * Sets appropriate output properties based on the number of output files generated.
 * @param conversion - The conversion item to update with output file information
 * @param outputFilePaths - Array of all output file paths from the conversion process
 * @returns Filtered array of output file paths excluding error.txt files
 */
function updateConversionOutputs(
  conversion: ConversionItem,
  outputFilePaths: string[],
): string[] {
  const filteredOutputPaths = outputFilePaths.filter(
    (filePath) => !filePath.endsWith('error.txt'),
  );

  if (filteredOutputPaths.length > 1) {
    conversion.outputFilePaths = filteredOutputPaths;
  } else if (filteredOutputPaths.length === 1) {
    conversion.outputFilePath = filteredOutputPaths[0];
  }

  conversion.errorFilePath = undefined;
  conversion.lastShownOutputFiles = [...filteredOutputPaths];

  return filteredOutputPaths;
}

/**
 * Opens output files in the VS Code editor's third column.
 * Reverts any already open files to ensure they show the latest content.
 * @param outputFilePaths - Array of absolute paths to output files to open
 * @returns Promise that resolves when all files have been opened
 */
async function openOutputFiles(outputFilePaths: string[]): Promise<void> {
  for (const outputFilePath of outputFilePaths) {
    const outputUri = vscode.Uri.file(outputFilePath);
    const outputEditor = vscode.window.visibleTextEditors.find(
      (editor) => editor.document.uri.fsPath === outputFilePath,
    );

    if (outputEditor) {
      await vscode.commands.executeCommand(
        'workbench.action.files.revert',
        outputUri,
      );
    }
    await vscode.window.showTextDocument(outputUri, {
      viewColumn: vscode.ViewColumn.Three,
      preview: false,
      preserveFocus: true,
    });
  }
}

/**
 * Handles conversion errors by creating and displaying an error file with detailed error information.
 * Creates an error.txt file in the outputs directory with timestamp, error message, and stack trace.
 * Falls back to showing an error message if file creation fails.
 * @param error - The error that occurred during conversion
 * @param conversion - The conversion item that failed
 * @param isRdfToCSVW - The conversion direction for error reporting
 * @returns Promise that resolves when error handling is complete
 */
async function handleConversionError(
  error: unknown,
  conversion: ConversionItem,
  isRdfToCSVW: boolean,
): Promise<void> {
  try {
    const conversionDirection = isRdfToCSVW ? 'RDF→CSVW' : 'CSVW→RDF';
    const errorMessage = `# Auto-conversion Error (${conversionDirection})\n# ${new Date().toISOString()}\n# Error: ${error instanceof Error ? error.message : String(error)}\n\n# Stack trace:\n# ${
      error instanceof Error && error.stack
        ? error.stack
            .split('\n')
            .map((line) => `# ${line}`)
            .join('\n')
        : 'No stack trace available'
    }\n`;

    const errorPath = vscode.Uri.file(
      `${conversion.folderPath}/outputs/error.txt`,
    );
    await vscode.workspace.fs.writeFile(
      errorPath,
      Buffer.from(errorMessage, 'utf8'),
    );

    const errorDocument = await vscode.workspace.openTextDocument(errorPath);
    await vscode.window.showTextDocument(
      errorDocument,
      vscode.ViewColumn.Three,
    );

    conversion.errorFilePath = errorPath.fsPath;
  } catch {
    const conversionDirection = isRdfToCSVW ? 'RDF→CSVW' : 'CSVW→RDF';
    vscode.window.showErrorMessage(
      `Auto-conversion failed (${conversionDirection}): ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

/**
 * Registers the save event listener that triggers auto-conversion when files are saved.
 * Monitors file save events and automatically converts CSVW↔RDF when input files are modified.
 * Handles different file types: descriptor updates, input file conversions, and error prevention for output files.
 * @param csvwActionsProvider - The tree data provider managing conversion items
 * @returns Disposable object for the save event listener
 */
export function registerSaveListener(
  csvwActionsProvider: CSVWActionsProvider,
): vscode.Disposable {
  return vscode.workspace.onDidSaveTextDocument(async (document) => {
    const changedFilePath = document.uri.fsPath;
    const conversions = csvwActionsProvider.getAllConversions();
    const conversion = findMatchingConversion(changedFilePath, conversions);

    if (!conversion) return;

    if (changedFilePath === conversion.descriptorFilePath) {
      await handleDescriptorSave(conversion);
      return;
    }

    const isRdfToCSVW = isRdfToCSVWConversion(changedFilePath, conversion);

    const descriptorEditor = vscode.window.visibleTextEditors.find(
      (editor) => editor.document.uri.fsPath === conversion.descriptorFilePath,
    );

    if (descriptorEditor) {
      try {
        const descriptorContent = descriptorEditor.document.getText();
        const outputFilePaths = await performConversion(
          conversion,
          descriptorContent,
          isRdfToCSVW,
        );
        const filteredOutputPaths = updateConversionOutputs(
          conversion,
          outputFilePaths,
        );

        if (filteredOutputPaths.length > 0) {
          await openOutputFiles(filteredOutputPaths);
        }
      } catch (error) {
        await handleConversionError(error, conversion, isRdfToCSVW);
      }
    }
  });
}
